<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Apuntes de Dart ‚Äì Fundamentos</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
</head>
<body class="bg-gray-50 text-gray-800 font-sans leading-relaxed">
    
  <div class="max-w-4xl mx-auto px-4 py-8">

    <!-- Header -->
    <header class="text-center mb-12">
      <h1 class="text-4xl font-bold text-indigo-700">Apuntes de Dart ‚Äì Fundamentos</h1>
      <p class="text-gray-600 mt-2">Gu√≠a esencial para aprender Dart: desde variables hasta programaci√≥n orientada a objetos</p>
    </header>

    <!-- Table of Contents -->
    <nav class="bg-white p-5 rounded-lg shadow mb-10">
      <h2 class="text-xl font-semibold text-gray-800 mb-3">Tabla de contenido</h2>
      <ul class="list-disc pl-5 space-y-1 text-gray-700">
        <li><a href="#intro" class="hover:text-indigo-600 transition">1. Introducci√≥n a Dart</a></li>
        <li><a href="#variables" class="hover:text-indigo-600 transition">2. Variables</a></li>
        <li><a href="#entrada" class="hover:text-indigo-600 transition">3. Entrada de Datos (desde consola)</a></li>
        <li><a href="#condicionales" class="hover:text-indigo-600 transition">4. Estructuras Condicionales</a></li>
        <li><a href="#bucles-control" class="hover:text-indigo-600 transition">5. Bucles y estructuras de control</a></li>
        <li><a href="#funciones" class="hover:text-indigo-600 transition">6. Funciones</a></li>
        <li><a href="#sets" class="hover:text-indigo-600 transition">7. Sets (conjuntos)</a></li>
        <li><a href="#map" class="hover:text-indigo-600 transition">8. Map (diccionarios)</a></li>
        <li><a href="#nulabilidad" class="hover:text-indigo-600 transition">9. Nulabilidad</a></li>
        <li><a href="#clases-poo" class="hover:text-indigo-600 transition">10. Clases y POO</a></li>
        <li><a href="#ejercicios" class="hover:text-indigo-600 transition">11. Ejercicios de prueba</a></li>
      </ul>
    </nav>

    <!-- Section 1 -->
    <section id="intro" class="mb-12 bg-white p-6 rounded-lg shadow">
      <h2 class="text-2xl font-bold text-indigo-600 mb-4">1. Introducci√≥n a Dart</h2>
      <p class="mb-4">
        Dart es un lenguaje de programaci√≥n moderno, desarrollado por Google, fuertemente tipado pero con soporte para inferencia de tipos. Se utiliza sobre todo en <strong>Flutter</strong> para desarrollo multiplataforma, aunque tambi√©n sirve para backend y aplicaciones de consola.
      </p>
      <h3 class="text-lg font-semibold mt-4 mb-2">Caracter√≠sticas principales:</h3>
      <ul class="list-disc pl-5 space-y-1 mb-4">
        <li>Sintaxis similar a C/Java.</li>
        <li>Orientado a objetos.</li>
        <li>Soporte para programaci√≥n as√≠ncrona (<code class="bg-gray-100 px-1 rounded">async</code> / <code class="bg-gray-100 px-1 rounded">await</code>).</li>
        <li>Tipado est√°tico pero flexible (inferencia de tipos).</li>
        <li>Soporte para nulabilidad segura (null safety).</li>
      </ul>
      <p class="mb-3"><strong>Probar y practicar con los ejemplos</strong></p>
      <p class="mb-3">Puedes usar <strong>Dartpad</strong> pero se quedar√° corto cuando deseemos importar paquetes, as√≠ que te propongo 2 soluciones:</p>
      <div class="bg-blue-50 p-4 rounded-lg">
        <h4 class="font-semibold text-blue-800 mb-2">OPCI√ìN 1. Replit</h4>
        <ul class="list-disc pl-5 space-y-1 text-blue-800 text-sm">
          <li>Replit ejecuta tu c√≥digo en un entorno de servidor real (no en el navegador como DartPad).</li>
          <li>Eso significa que s√≠ soporta <code class="bg-blue-100 px-1 rounded">dart:io</code>, incluyendo: <code>stdin.readLineSync()</code> ‚Üí para leer entrada del usuario.</li>
          <li><code>File</code> ‚Üí para leer/escribir archivos. <code>Process</code>, <code>HttpClient</code>, etc.</li>
          <li>No necesitas instalar nada en tu computadora (todo est√° en la nube).</li>
          <li>Es gratis para uso b√°sico (con cuenta de Replit).</li>
        </ul>
        <p class="mt-3"><strong>üîß C√≥mo usar Dart en Replit</strong></p>
        <ol class="list-decimal pl-5 space-y-1 text-sm">
          <li>Ve a <a href="https://replit.com" target="_blank" class="text-blue-600 hover:underline">https://replit.com</a></li>
          <li>Crea una cuenta (o inicia sesi√≥n).</li>
          <li>Haz clic en <strong>+ Create Repl</strong> (o "New repl").</li>
          <li>Busca "Dart" en el buscador de lenguajes.</li>
          <li>Selecciona el template "Dart".</li>
        </ol>
      </div>
      <div class="bg-green-50 p-4 rounded-lg mt-4">
        <h4 class="font-semibold text-green-800 mb-2">OPCI√ìN 2. Instalar Flutter en tu equipo (nos servir√° m√°s adelante)</h4>
        <p class="text-green-800 text-sm">Ver v√≠deo</p>
      </div>
    <br>
  <h2 class="text-2xl font-bold text-indigo-600 mb-4">1.1 ¬øPor qu√© aprender Dart para Flutter?</h2>
  
  <p class="text-gray-700 mb-4">
    Antes de comenzar a aprender Flutter, es imprescindible dominar primero el lenguaje Dart. Flutter utiliza Dart para definir toda la l√≥gica, las estructuras de datos, la gesti√≥n del estado y gran parte del comportamiento interno de una aplicaci√≥n.
  </p>
  
  <p class="text-gray-700 mb-4">
    Aunque Flutter incorpora su propio conjunto de widgets y herramientas para construir interfaces, el c√≥digo que los hace funcionar sigue siendo Dart. Por eso es fundamental saber diferenciar qu√© pertenece al lenguaje y qu√© forma parte del framework.
  </p>
  
  <p class="text-gray-700 mb-4">
    Los elementos que se describen en este manual ‚Äîvariables, tipos de datos, funciones, clases, constantes y dem√°s fundamentos‚Äî son esenciales para comprender c√≥mo opera Flutter por dentro y para poder escribir aplicaciones eficientes, limpias y mantenibles.
  </p>
  
  <p class="text-gray-700">
    <b>Sin una base s√≥lida en Dart, aprender Flutter se vuelve confuso y limitado; con ella, en cambio, se potencia el aprendizaje y se facilita el desarrollo profesional.</b>
  </p>
</section>

    <!-- Section 2 -->
    <section id="variables" class="mb-12 bg-white p-6 rounded-lg shadow">
      <h2 class="text-2xl font-bold text-indigo-600 mb-4">2. Variables</h2>
      <p class="mb-4">
        En Dart, una variable es un espacio en memoria donde se almacena un valor. El lenguaje permite declarar variables de diferentes maneras seg√∫n el nivel de estrictitud y el momento en que se conoce el tipo del dato.
      </p>

      <h3 class="text-lg font-semibold mt-5 mb-2">2.1 Declaraci√≥n con tipo expl√≠cito</h3>
      <p>Dart permite especificar directamente el tipo de dato que contendr√° la variable. Esto mejora la claridad del c√≥digo y evita errores.</p>
      <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
        int edad = 20;
      </div>
      <ul class="list-disc pl-5 space-y-1 mb-4 text-sm">
        <li><code>int</code> indica que la variable solo podr√° almacenar n√∫meros enteros.</li>
        <li>El tipo expl√≠cito ayuda al compilador a detectar asignaciones incorrectas.</li>
      </ul>

      <h3 class="text-lg font-semibold mt-5 mb-2">2.2 Declaraci√≥n con inferencia de tipo (<code>var</code>)</h3>
      <p>Cuando se utiliza <code>var</code>, Dart determina autom√°ticamente el tipo de la variable a partir del valor asignado.</p>
      <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
        var nombre = "Ana";
      </div>
      <ul class="list-disc pl-5 space-y-1 mb-4 text-sm">
        <li>El compilador infiere que <code>nombre</code> es un <code>String</code>.</li>
        <li>Una vez inferido, el tipo no puede cambiar.</li>
      </ul>

      <h3 class="text-lg font-semibold mt-5 mb-2">2.3 Constantes: <code>const</code> y <code>final</code></h3>
      <p>Dart ofrece dos palabras clave para definir valores que no cambiar√°n:</p>
      <div class="mt-3">
        <p><strong><code>const</code> ‚Äì Constantes en tiempo de compilaci√≥n</strong></p>
        <div class="bg-gray-800 text-green-400 p-4 rounded my-2 font-mono text-sm overflow-x-auto">
          const double pi = 3.1416;
        </div>
        <ul class="list-disc pl-5 space-y-1 text-sm mb-3">
          <li>El valor debe ser conocido antes de ejecutar el programa.</li>
          <li>√ötil para valores completamente inmutables.</li>
        </ul>
        <p><strong><code>final</code> ‚Äì Constantes en tiempo de ejecuci√≥n</strong></p>
        <div class="bg-gray-800 text-green-400 p-4 rounded my-2 font-mono text-sm overflow-x-auto">
          final fecha = DateTime.now();
        </div>
        <ul class="list-disc pl-5 space-y-1 text-sm">
          <li>Su valor se asigna una sola vez, pero puede calcularse durante la ejecuci√≥n.</li>
          <li>Ideal para valores din√°micos pero inmutables.</li>
        </ul>
      </div>

      <h3 class="text-lg font-semibold mt-5 mb-2">2.4 Ejemplo completo</h3>
      <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
        <pre>void main() {
  // Declaraci√≥n con tipo expl√≠cito
  int edad = 20;
  // Declaraci√≥n con inferencia de tipo
  var nombre = "Ana";
  // Constantes
  const double pi = 3.1416; // tiempo de compilaci√≥n
  final fecha = DateTime.now(); // tiempo de ejecuci√≥n
  print("Edad: $edad, Nombre: $nombre, Pi: $pi, Fecha: $fecha");
}</pre>
      </div>
      <div class="bg-yellow-50 p-3 rounded text-sm mt-2">
        <strong>Nota:</strong>
        <ul class="list-disc pl-5 mt-1">
          <li><code>var</code> ‚Üí infiere el tipo.</li>
          <li><code>const</code> ‚Üí valor fijo en compilaci√≥n.</li>
          <li><code>final</code> ‚Üí valor fijo en tiempo de ejecuci√≥n.</li>
        </ul>
      </div>
    </section>

    <!-- Section 3: Entrada de datos -->
  <section id="entrada" class="mb-12 bg-white p-6 rounded-lg shadow">
      <h2 class="text-2xl font-bold text-indigo-600 mb-4">3. Entrada de Datos (desde consola)</h2>
  
  <p class="text-gray-700 mb-4">
    En Dart, para leer datos desde la consola (entrada est√°ndar), se utiliza la librer√≠a 
    <code class="bg-gray-100 px-1 rounded">dart:io</code>, espec√≠ficamente la propiedad 
    <code class="bg-gray-100 px-1 rounded">stdin</code>.
  </p>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Lectura b√°sica de texto</h3>
  <p class="text-gray-700 mb-3">
    El m√©todo <code class="bg-gray-100 px-1 rounded">readLineSync()</code> lee una l√≠nea completa introducida por el usuario
    y devuelve un <code class="bg-gray-100 px-1 rounded">String?</code> (puede ser <code>null</code> si no hay datos).
  </p>
  <pre class="bg-gray-900 text-gray-100 p-4 rounded-lg overflow-x-auto text-sm mb-6">
<code class="language-dart">import 'dart:io';

void main() {
  print("Introduce tu nombre:");
  String? nombre = stdin.readLineSync();
  print("Hola, \$nombre!");
}</code>
  </pre>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Conversi√≥n a otros tipos</h3>
  <p class="text-gray-700 mb-3">
    Como <code>readLineSync()</code> devuelve un <code>String?</code>, es com√∫n convertirlo a otros tipos
    como <code>int</code>, <code>double</code>, etc. Es importante manejar posibles errores con <code>try-catch</code>.
  </p>
  <pre class="bg-gray-900 text-gray-100 p-4 rounded-lg overflow-x-auto text-sm mb-6">
<code class="language-dart">import 'dart:io';

void main() {
  print("Introduce tu edad:");
  String? input = stdin.readLineSync();
  
  if (input != null) {
    try {
      int edad = int.parse(input.trim());
      print("Tienes \$edad a√±os.");
    } catch (e) {
      print("Entrada no v√°lida. Por favor, introduce un n√∫mero entero.");
    }
  }
}</code>
  </pre>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Notas importantes</h3>
  <ul class="list-disc pl-5 text-gray-700 space-y-2">
    <li>
      <code class="bg-gray-100 px-1 rounded">readLineSync()</code> devuelve <code>null</code> si se alcanza el final del flujo de entrada (por ejemplo, al presionar Ctrl+D en Unix o Ctrl+Z en Windows).
    </li>
    <li>
      Siempre es buena pr√°ctica verificar que el valor no sea <code>null</code> antes de usarlo.
    </li>
    <li>
      Usa <code class="bg-gray-100 px-1 rounded">.trim()</code> para eliminar espacios innecesarios al principio o al final de la entrada.
    </li>
    <li>
      La interpolaci√≥n de cadenas con <code>\$variable</code> facilita la inclusi√≥n de valores en mensajes.
    </li>
  </ul>
    </section>


    <!-- Section 4 -->
<section id="condicionales" class="mb-12 bg-white p-6 rounded-lg shadow">
  <h2 class="text-2xl font-bold text-indigo-600 mb-4">4. Estructuras Condicionales</h2>

  <p class="text-gray-700 mb-4">
    Las estructuras condicionales permiten ejecutar diferentes bloques de c√≥digo seg√∫n se cumpla o no una condici√≥n.
    Dart admite las instrucciones <code class="bg-gray-100 px-1 rounded">if</code>, <code class="bg-gray-100 px-1 rounded">else if</code>, 
    <code class="bg-gray-100 px-1 rounded">else</code>, y el operador ternario para expresiones condicionales.
  </p>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Condicional <code class="bg-gray-100 px-1 rounded">if-else</code></h3>
  <p class="text-gray-700 mb-3">
    La estructura b√°sica eval√∫a una expresi√≥n booleana. Si es <code>true</code>, se ejecuta el bloque <code>if</code>;
    de lo contrario, se ejecuta el bloque <code>else</code> (si est√° presente).
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>void main() {
  int edad = 18;
  if (edad >= 18) {
    print("Eres mayor de edad.");
  } else {
    print("Eres menor de edad.");
  }
}</pre>
  </div>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Operador ternario</h3>
  <p class="text-gray-700 mb-3">
    El operador ternario es una forma concisa de asignar un valor basado en una condici√≥n. 
    Sintaxis: <code class="bg-gray-100 px-1 rounded">condici√≥n ? valorSiTrue : valorSiFalse</code>.
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>// Operador ternario
String permiso = edad >= 18 ? "Permitido" : "Denegado";
print("Acceso: \$permiso");</pre>
  </div>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">M√∫ltiples condiciones con <code class="bg-gray-100 px-1 rounded">else if</code></h3>
  <p class="text-gray-700 mb-3">
    Puedes encadenar varias condiciones para manejar m√∫ltiples casos.
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>int calificacion = 85;

if (calificacion >= 90) {
  print("Excelente");
} else if (calificacion >= 70) {
  print("Aprobado");
} else if (calificacion >= 50) {
  print("Aprobado con dificultad");
} else {
  print("Reprobado");
}</pre>
  </div>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Condiciones con operadores l√≥gicos</h3>
  <p class="text-gray-700 mb-3">
    Puedes combinar condiciones usando <code>&&</code> (AND), <code>||</code> (OR) y <code>!</code> (NOT).
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>int edad = 20;
bool tieneLicencia = true;

if (edad >= 18 && tieneLicencia) {
  print("Puede conducir legalmente.");
} else if (edad >= 18 && !tieneLicencia) {
  print("Es mayor de edad, pero necesita licencia.");
} else {
  print("No puede conducir.");
}</pre>
  </div>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Notas importantes</h3>
  <ul class="list-disc pl-5 text-gray-700 space-y-2">
    <li>
      En Dart, solo los valores booleanos (<code>true</code> o <code>false</code>) son v√°lidos en condiciones.
      No se consideran "falsos" valores como <code>0</code>, <code>""</code> o <code>null</code> (a diferencia de otros lenguajes).
    </li>
    <li>
      Si omites las llaves <code>{}</code> en un bloque <code>if</code>, solo se ejecutar√° la siguiente l√≠nea.
      Por legibilidad y seguridad, se recomienda siempre usar llaves.
    </li>
    <li>
      El operador ternario debe tener ambos lados definidos; no se puede omitir la parte <code>: valorSiFalse</code>.
    </li>
  </ul>
</section>
   <!-- Section 15 -->
<section id="bucles-control" class="mb-12 bg-white p-6 rounded-lg shadow">
  <h2 class="text-2xl font-bold text-indigo-600 mb-4">5. Bucles y Estructuras de Control</h2>

  <p class="text-gray-700 mb-4">
    Dart ofrece varias estructuras para controlar el flujo de ejecuci√≥n: bucles para repetir tareas
    (<code class="bg-gray-100 px-1 rounded">for</code>, <code class="bg-gray-100 px-1 rounded">while</code>, <code class="bg-gray-100 px-1 rounded">do-while</code>)
    y la instrucci√≥n <code class="bg-gray-100 px-1 rounded">switch</code> para tomar decisiones m√∫ltiples basadas en un valor.
  </p>

  <!-- For loop -->
  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Bucle <code class="bg-gray-100 px-1 rounded">for</code></h3>
  <p class="text-gray-700 mb-3">
    Ideal para iterar un n√∫mero conocido de veces. La sintaxis cl√°sica incluye inicializaci√≥n, condici√≥n y actualizaci√≥n.
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>for (int i = 0; i &lt; 5; i++) {
  print("Iteraci√≥n \$i");
}</pre>
  </div>

  <p class="text-gray-700 mb-3">
    Dart tambi√©n soporta el bucle <code>for-in</code> para recorrer colecciones como listas.
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>List&lt;String&gt; frutas = ['manzana', 'pl√°tano', 'naranja'];
for (String fruta in frutas) {
  print("Me gusta la \$fruta");
}</pre>
  </div>

  <!-- While loop -->
  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Bucle <code class="bg-gray-100 px-1 rounded">while</code></h3>
  <p class="text-gray-700 mb-3">
    Ejecuta un bloque de c√≥digo mientras una condici√≥n sea <code>true</code>.
    La condici√≥n se eval√∫a antes de cada iteraci√≥n.
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>int contador = 3;
while (contador > 0) {
  print("Cuenta regresiva: \$contador");
  contador--;
}</pre>
  </div>

  <p class="text-gray-700 mb-3">
    El bucle <code>do-while</code> es similar, pero garantiza que el bloque se ejecute al menos una vez,
    ya que la condici√≥n se eval√∫a al final.
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>int intentos = 0;
do {
  print("Intento n√∫mero \${intentos + 1}");
  intentos++;
} while (intentos < 3);</pre>
  </div>

  <!-- Switch statement -->
  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Instrucci√≥n <code class="bg-gray-100 px-1 rounded">switch</code></h3>
  <p class="text-gray-700 mb-3">
    Permite comparar un valor contra m√∫ltiples casos. Dart requiere que los casos sean constantes
    (como literales o valores <code>const</code>).
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>String dia = "lunes";

switch (dia) {
  case "lunes":
    print("Inicio de la semana");
    break;
  case "viernes":
    print("Fin de la semana laboral");
    break;
  case "s√°bado":
  case "domingo":
    print("Fin de semana");
    break;
  default:
    print("D√≠a entre semana");
}</pre>
  </div>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Notas importantes</h3>
  <ul class="list-disc pl-5 text-gray-700 space-y-2">
    <li>
      En Dart, <code>switch</code> no permite "ca√≠da" (<i>fall-through</i>) entre casos, excepto si el caso est√° vac√≠o
      (como <code>case "s√°bado":</code> seguido inmediatamente de <code>case "domingo":</code>).
    </li>
    <li>
      Siempre incluye <code>break</code>, <code>return</code> o <code>continue</code> al final de un caso no vac√≠o;
      de lo contrario, el c√≥digo no compilar√°.
    </li>
    <li>
      Los bucles <code>for-in</code> son ideales para colecciones, pero no permiten modificar la colecci√≥n durante la iteraci√≥n.
    </li>
    <li>
      Usa <code>while</code> cuando no sepas cu√°ntas iteraciones necesitar√°s (por ejemplo, lectura de datos hasta que el usuario escriba "salir").
    </li>
  </ul>
</section>

    <!-- Section 6 -->
    <!-- Section 6 -->
<section id="funciones" class="mb-12 bg-white p-6 rounded-lg shadow">
  <h2 class="text-2xl font-bold text-indigo-600 mb-4">6. Funciones</h2>

  <p class="text-gray-700 mb-4">
    Las funciones en Dart son bloques de c√≥digo reutilizables que pueden recibir par√°metros y devolver un valor.
    Dart es un lenguaje con tipado est√°tico, por lo que se recomienda especificar los tipos de los par√°metros y del valor de retorno.
  </p>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Funci√≥n b√°sica con retorno</h3>
  <p class="text-gray-700 mb-3">
    Una funci√≥n t√≠pica declara el tipo de retorno, nombre, par√°metros y cuerpo con llaves.
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>// Funci√≥n con par√°metros y retorno
int sumar(int a, int b) {
  return a + b;
}</pre>
  </div>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Funciones flecha (<i>arrow functions</i>)</h3>
  <p class="text-gray-700 mb-3">
    Cuando el cuerpo de la funci√≥n es una sola expresi√≥n, puedes usar la sintaxis de flecha (<code>=></code>).
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>// Funci√≥n flecha (equivalente a la anterior)
int multiplicar(int a, int b) => a * b;</pre>
  </div>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Par√°metros opcionales</h3>
  <p class="text-gray-700 mb-3">
    Dart admite dos tipos de par√°metros opcionales: <strong>nombrados</strong> y <strong>posicionales</strong>.
  </p>

  <h4 class="text-md font-medium text-gray-700 mt-3">Par√°metros nombrados (entre llaves <code>{}</code>)</h4>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>void saludar({String nombre = "Invitado", int edad = 0}) {
  print("Hola \$nombre, tienes \$edad a√±os.");
}

// Uso
saludar(nombre: "Ana", edad: 25);
saludar(nombre: "Luis"); // edad usar√° valor por defecto
saludar(); // usa ambos valores por defecto</pre>
  </div>

  <h4 class="text-md font-medium text-gray-700 mt-3">Par√°metros posicionales opcionales (entre corchetes <code>[]</code>)</h4>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>String formatearNombre(String nombre, [String? apellido]) {
  if (apellido != null) {
    return "\$nombre \$apellido";
  }
  return nombre;
}

// Uso
print(formatearNombre("Mar√≠a"));           // "Mar√≠a"
print(formatearNombre("Carlos", "Ruiz"));  // "Carlos Ruiz"</pre>
  </div>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Funciones como ciudadanos de primera clase</h3>
  <p class="text-gray-700 mb-3">
    En Dart, las funciones se pueden asignar a variables, pasar como argumentos o devolver desde otras funciones.
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>int operacion(int a, int b, Function(int, int) fn) {
  return fn(a, b);
}

int restar(int x, int y) => x - y;

void main() {
  int resultado = operacion(10, 3, restar);
  print(resultado); // 7
}</pre>
  </div>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Funciones an√≥nimas</h3>
  <p class="text-gray-700 mb-3">
    √ötiles para callbacks o funciones de corta duraci√≥n. No tienen nombre.
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>void main() {
  List&lt;int&gt; numeros = [1, 2, 3];
  numeros.forEach((n) => print(n * 2)); // 2, 4, 6
}</pre>
  </div>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Notas importantes</h3>
  <ul class="list-disc pl-5 text-gray-700 space-y-2">
    <li>
      Si una funci√≥n no devuelve un valor, se declara con <code>void</code>.
    </li>
    <li>
      Los par√°metros nombrados son opcionales por defecto, pero puedes hacerlos obligatorios usando <code>required</code> (desde Dart 2.12+ con nulabilidad).
    </li>
    <li>
      Las funciones flecha no usan llaves ni la palabra <code>return</code>; la expresi√≥n se devuelve autom√°ticamente.
    </li>
    <li>
      Puedes combinar par√°metros obligatorios, posicionales opcionales y nombrados, pero deben aparecer en este orden:  
      <code>func(a, [b], {c})</code>.
    </li>
  </ul>
</section>

    <!-- Section 8 -->
<section id="sets" class="mb-12 bg-white p-6 rounded-lg shadow">
  <h2 class="text-2xl font-bold text-indigo-600 mb-4">7. Sets (conjuntos)</h2>

  <p class="text-gray-700 mb-4">
    Un <code class="bg-gray-100 px-1 rounded">Set</code> en Dart es una colecci√≥n no ordenada de elementos <strong>√∫nicos</strong>.
    No permite duplicados, y el orden de los elementos no est√° garantizado.
  </p>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Creaci√≥n y caracter√≠sticas b√°sicas</h3>
  <p class="text-gray-700 mb-3">
    Puedes crear un <code>Set</code> usando llaves <code>{}</code> o el constructor <code>Set()</code>.
    Los elementos duplicados se ignoran autom√°ticamente.
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>void main() {
  Set&lt;int&gt; numeros = {1, 2, 3, 3, 4};
  print(numeros); // {1, 2, 3, 4} ‚Üí sin duplicados
  numeros.add(5);
  numeros.remove(2);
  print(numeros); // {1, 3, 4, 5}
}</pre>
  </div>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">M√©todos comunes de <code>Set</code></h3>
  <p class="text-gray-700 mb-3">
    Los <code>Set</code> ofrecen operaciones √∫tiles como uni√≥n, intersecci√≥n y diferencia.
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>void main() {
  Set&lt;String&gt; a = {'manzana', 'pl√°tano', 'naranja'};
  Set&lt;String&gt; b = {'pl√°tano', 'kiwi', 'naranja'};

  print('Uni√≥n: \${a.union(b)}');            
  // {manzana, pl√°tano, naranja, kiwi}

  print('Intersecci√≥n: \${a.intersection(b)}'); 
  // {pl√°tano, naranja}

  print('Diferencia (a - b): \${a.difference(b)}'); 
  // {manzana}
}</pre>
  </div>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Verificaci√≥n de elementos</h3>
  <p class="text-gray-700 mb-3">
    Usa <code>.contains()</code> para comprobar si un elemento existe en el conjunto.
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>Set&lt;int&gt; numeros = {10, 20, 30};
if (numeros.contains(20)) {
  print("20 est√° en el conjunto");
}</pre>
  </div>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Iteraci√≥n sobre un <code>Set</code></h3>
  <p class="text-gray-700 mb-3">
    Aunque el orden no est√° garantizado, puedes recorrer los elementos con un bucle <code>for-in</code>.
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>Set&lt;String&gt; colores = {'rojo', 'verde', 'azul'};
for (String color in colores) {
  print("Color: \$color");
}</pre>
  </div>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Notas importantes</h3>
  <ul class="list-disc pl-5 text-gray-700 space-y-2">
    <li>
      Los <code>Set</code> son ideales cuando necesitas almacenar elementos √∫nicos y no te importa el orden.
    </li>
    <li>
      Si intentas crear un <code>Set</code> vac√≠o con <code>{}</code>, Dart lo interpretar√° como un <code>Map</code>.
      Usa <code>&lt;Tipo&gt;{}</code> o <code>Set&lt;Tipo&gt;()</code> para evitar ambig√ºedades:
      <code class="bg-gray-100 px-1 rounded">Set&lt;int&gt; vacio = &lt;int&gt;{};</code>.
    </li>
    <li>
      Los elementos de un <code>Set</code> deben ser comparables (implementar <code>==</code> y <code>hashCode</code> correctamente).
    </li>
    <li>
      A diferencia de las <code>List</code>, no puedes acceder a un elemento por √≠ndice en un <code>Set</code>.
    </li>
  </ul>
</section>

   <!-- Section 9 -->
<section id="map" class="mb-12 bg-white p-6 rounded-lg shadow">
  <h2 class="text-2xl font-bold text-indigo-600 mb-4">8. Map (diccionarios)</h2>

  <p class="text-gray-700 mb-4">
    Un <code class="bg-gray-100 px-1 rounded">Map</code> en Dart almacena pares de <strong>clave-valor</strong>.
    Cada clave debe ser √∫nica, y se puede acceder al valor asociado mediante dicha clave.
    Los <code>Map</code> son ideales para representar datos estructurados como configuraciones, cat√°logos o registros.
  </p>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Creaci√≥n y acceso b√°sico</h3>
  <p class="text-gray-700 mb-3">
    Puedes crear un <code>Map</code> con llaves <code>{}</code> o con el constructor <code>Map()</code>.
    El acceso a un valor se hace con el operador <code>[]</code>, que devuelve <code>null</code> si la clave no existe.
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>void main() {
  Map&lt;String, String&gt; capitales = {
    "Espa√±a": "Madrid",
    "Francia": "Par√≠s",
    "Italia": "Roma"
  };
  print(capitales["Espa√±a"]); // "Madrid"
  
  // A√±adir o actualizar
  capitales["Portugal"] = "Lisboa";
  
  // Recorrer el mapa
  capitales.forEach((pais, capital) {
    print("\$pais ‚Üí \$capital");
  });
}</pre>
  </div>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">M√©todos comunes</h3>
  <p class="text-gray-700 mb-3">
    Los <code>Map</code> ofrecen m√∫ltiples m√©todos para manipular y consultar sus datos.
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>Map&lt;String, int&gt; edades = {"Ana": 25, "Luis": 30};

// Verificar si existe una clave
if (edades.containsKey("Ana")) {
  print("Ana tiene \${edades["Ana"]} a√±os");
}

// Verificar si existe un valor
if (edades.containsValue(30)) {
  print("Alguien tiene 30 a√±os");
}

// Obtener todas las claves o valores
print("Claves: \${edades.keys}");     // (Ana, Luis)
print("Valores: \${edades.values}");   // (25, 30)

// Eliminar un par
edades.remove("Luis");
print(edades); // {Ana: 25}</pre>
  </div>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Valores por defecto con <code>putIfAbsent</code></h3>
  <p class="text-gray-700 mb-3">
    Evita <code>null</code> al acceder a claves inexistentes usando m√©todos como <code>putIfAbsent</code> o el operador de nulabilidad.
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>Map&lt;String, int&gt; puntuaciones = {"jugador1": 100};

// Si no existe, asigna un valor por defecto
int score = puntuaciones.putIfAbsent("jugador2", () => 0);
print(score); // 0
print(puntuaciones); // {jugador1: 100, jugador2: 0}

// O simplemente con operador ??
int score2 = puntuaciones["jugador3"] ?? 0;
print(score2); // 0 (sin modificar el mapa)</pre>
  </div>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Mapas anidados</h3>
  <p class="text-gray-700 mb-3">
    Es com√∫n usar <code>Map</code> dentro de otros <code>Map</code> para representar estructuras complejas.
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>Map&lt;String, Map&lt;String, dynamic&gt;&gt; usuarios = {
  "user1": {
    "nombre": "Carlos",
    "edad": 28,
    "activo": true
  },
  "user2": {
    "nombre": "Luc√≠a",
    "edad": 32,
    "activo": false
  }
};

print(usuarios["user1"]?["nombre"]); // "Carlos"</pre>
  </div>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Notas importantes</h3>
  <ul class="list-disc pl-5 text-gray-700 space-y-2">
    <li>
      Las claves en un <code>Map</code> deben ser objetos inmutables o que no cambien su <code>hashCode</code> (como <code>String</code>, <code>int</code>, etc.).
    </li>
    <li>
      Al igual que con los <code>Set</code>, usar <code>{}</code> sin tipo puede interpretarse como <code>Map</code> o <code>Set</code>.
      Para evitar ambig√ºedad, especifica el tipo: <code>Map&lt;String, int&gt; datos = {};</code>.
    </li>
    <li>
      El operador <code>[]</code> devuelve <code>null</code> si la clave no existe (en modo nul-safety, el tipo ser√° <code>V?</code>).
    </li>
    <li>
      Puedes usar <code>entries</code> para iterar sobre pares clave-valor como objetos <code>MapEntry</code>.
    </li>
  </ul>
</section>

 

   <!-- Section 12 -->
<section id="nulabilidad" class="mb-12 bg-white p-6 rounded-lg shadow">
  <h2 class="text-2xl font-bold text-indigo-600 mb-4">9. Nulabilidad (Null Safety)</h2>

  <p class="text-gray-700 mb-4">
    Dart incluye <strong>Null Safety</strong> desde la versi√≥n 2.12, un sistema que evita errores en tiempo de ejecuci√≥n
    al garantizar que no se acceda a valores <code>null</code> de forma accidental.
    Cada variable debe declararse expl√≠citamente como nulable o no nulable.
  </p>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Tipos no nulables vs. tipos nulables</h3>
  <p class="text-gray-700 mb-3">
    Por defecto, los tipos en Dart <strong>no permiten</strong> <code>null</code>. Para permitirlo, a√±ade <code>?</code> al tipo.
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>// No nulable ‚Üí debe inicializarse
String nombre = "Ana";

// Nulable ‚Üí puede ser null
String? apellido;

// ‚ùå Error de compilaci√≥n:
// String ciudad; // No inicializada y no nulable ‚Üí ¬°no compila!
String? ciudad; // ‚úÖ V√°lido</pre>
  </div>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Operadores para trabajar con nulabilidad</h3>
  <p class="text-gray-700 mb-3">
    Dart proporciona operadores seguros para manejar valores que podr√≠an ser <code>null</code>.
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>void main() {
  String? nombre;

  // Operador ?? ‚Üí valor por defecto si es null
  print(nombre ?? "Desconocido"); // "Desconocido"

  // Asignar valor
  nombre = "Laura";

  // Operador ?. ‚Üí invocaci√≥n segura
  print(nombre?.toUpperCase()); // "LAURA"

  // Operador ! ‚Üí afirmaci√≥n de no nulidad (¬°cuidado!)
  print(nombre!.length); // 5 (solo si est√°s seguro de que no es null)
}</pre>
  </div>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Inicializaci√≥n tard√≠a con <code>late</code></h3>
  <p class="text-gray-700 mb-3">
    Si sabes que una variable no nulable se inicializar√° antes de usarse (pero no en la declaraci√≥n),
    puedes usar la palabra clave <code>late</code>.
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>late String configuracion;

void cargarConfiguracion() {
  configuracion = "modo-oscuro";
}

void main() {
  cargarConfiguracion();
  print(configuracion); // ‚úÖ V√°lido gracias a "late"
}</pre>
  </div>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Manejo seguro en funciones y par√°metros</h3>
  <p class="text-gray-700 mb-3">
    Los par√°metros de funciones tambi√©n pueden ser nulables, y debes manejarlos adecuadamente.
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>void saludar(String? nombre) {
  if (nombre != null) {
    print("Hola, \$nombre");
  } else {
    print("Hola, invitado");
  }
  // O de forma m√°s concisa:
  print("Bienvenido, \${nombre ?? "invitado"}");
}</pre>
  </div>

  <div class="bg-yellow-50 p-3 rounded text-sm mt-6">
    <strong>üîë Notas clave:</strong>
    <ul class="list-disc pl-5 mt-1 space-y-1">
      <li><code>String</code> ‚Üí nunca puede ser <code>null</code>.</li>
      <li><code>String?</code> ‚Üí puede contener una cadena o <code>null</code>.</li>
      <li><code>??</code> ‚Üí devuelve el valor de la izquierda si no es <code>null</code>; si lo es, devuelve el de la derecha.</li>
      <li><code>?.</code> ‚Üí invoca un m√©todo o accede a una propiedad solo si el objeto no es <code>null</code>.</li>
      <li><code>!</code> ‚Üí fuerza el acceso asumiendo que no es <code>null</code> (usa con precauci√≥n).</li>
      <li><code>late</code> ‚Üí para variables no nulables que se inicializan despu√©s de la declaraci√≥n.</li>
    </ul>
  </div>
 <p class="text-gray-700 mt-4 text-sm italic">
    Null Safety no solo previene errores, sino que mejora la legibilidad y mantenibilidad del c√≥digo al hacer expl√≠citas las intenciones del desarrollador.
  </p>
</section>
  <!-- Section 13 -->
<section id="clases-poo" class="mb-12 bg-white p-6 rounded-lg shadow">
  <h2 class="text-2xl font-bold text-indigo-600 mb-4">10. Clases y Programaci√≥n Orientada a Objetos (POO)</h2>

  <p class="text-gray-700 mb-4">
    Dart es un lenguaje orientado a objetos. Todo valor es un objeto, incluyendo n√∫meros, funciones y <code>null</code>.
    Las clases definen la estructura y comportamiento de los objetos mediante propiedades (atributos) y m√©todos.
  </p>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Definici√≥n b√°sica de una clase</h3>
  <p class="text-gray-700 mb-3">
    Una clase se define con la palabra clave <code>class</code>. Incluye campos (propiedades) y m√©todos (comportamientos).
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>class Persona {
  String nombre;
  int edad;

  // Constructor
  Persona(this.nombre, this.edad);

  // M√©todo
  void saludar() {
    print("Hola, soy \$nombre y tengo \$edad a√±os.");
  }
}

void main() {
  var persona = Persona("Carlos", 30);
  persona.saludar(); // Hola, soy Carlos y tengo 30 a√±os.
}</pre>
  </div>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Constructores y propiedades</h3>
  <p class="text-gray-700 mb-3">
    Dart permite una sintaxis concisa para asignar par√°metros del constructor a propiedades usando <code>this.</code>.
    Tambi√©n puedes usar constructores con par√°metros nombrados.
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>class Coche {
  String marca;
  String? color; // opcional

  // Constructor con par√°metros nombrados
  Coche({required this.marca, this.color});

  String get info => "Coche: \$marca \${color ?? 'sin color'}";
}

void main() {
  var coche1 = Coche(marca: "Toyota");
  var coche2 = Coche(marca: "Ford", color: "Rojo");
  print(coche1.info); // Coche: Toyota sin color
  print(coche2.info); // Coche: Ford Rojo
}</pre>
  </div>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Herencia</h3>
  <p class="text-gray-700 mb-3">
    Una clase puede heredar de otra usando <code>extends</code>. Dart no admite herencia m√∫ltiple,
    pero s√≠ mixins (ver m√°s abajo).
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>class Animal {
  String nombre;
  Animal(this.nombre);

  void hacerSonido() {
    print("\$nombre hace un sonido.");
  }
}

class Perro extends Animal {
  Perro(String nombre) : super(nombre);

  @override
  void hacerSonido() {
    print("\$nombre dice: ¬°Guau!");
  }
}

void main() {
  var perro = Perro("Firulais");
  perro.hacerSonido(); // Firulais dice: ¬°Guau!
}</pre>
  </div>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">M√©todos getter y setter</h3>
  <p class="text-gray-700 mb-3">
    Puedes definir propiedades calculadas o controlar el acceso con <code>get</code> y <code>set</code>.
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>class Rectangulo {
  double ancho, alto;
  Rectangulo(this.ancho, this.alto);

  // Getter calculado
  double get area => ancho * alto;

  // Setter personalizado
  set escalar(double factor) {
    ancho *= factor;
    alto *= factor;
  }
}

void main() {
  var r = Rectangulo(4, 5);
  print(r.area); // 20
  r.escalar = 2;
  print(r.area); // 80
}</pre>
  </div>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Mixins: reutilizaci√≥n de c√≥digo sin herencia</h3>
  <p class="text-gray-700 mb-3">
    Los <code>mixin</code> permiten inyectar funcionalidad en m√∫ltiples clases, incluso si no est√°n relacionadas.
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>mixin Volador {
  void volar() {
    print("¬°Estoy volando!");
  }
}

class Pajaro extends Animal with Volador {
  Pajaro(String nombre) : super(nombre);
}

void main() {
  var ave = Pajaro("√Åguila");
  ave.hacerSonido(); // √Åguila hace un sonido.
  ave.volar();       // ¬°Estoy volando!
}</pre>
  </div>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Notas importantes</h3>
  <ul class="list-disc pl-5 text-gray-700 space-y-2">
    <li>
      Todas las clases en Dart heredan impl√≠citamente de <code>Object</code>.
    </li>
    <li>
      Usa <code>@override</code> para indicar que est√°s sobrescribiendo un m√©todo (mejora la legibilidad y evita errores).
    </li>
    <li>
      Los constructores no se heredan, pero puedes llamar al constructor de la clase padre con <code>super()</code>.
    </li>
    <li>
      Dart no tiene modificadores de acceso como <code>public</code> o <code>private</code>; todo es p√∫blico.
      Para simular privacidad, usa el guion bajo: <code>_propiedad</code> (solo visible dentro de la biblioteca).
    </li>
  </ul>
</section>
<!-- Section 14 -->
<section id="ejercicios" class="mb-12 bg-white p-6 rounded-lg shadow">
  <h2 class="text-2xl font-bold text-indigo-600 mb-4">11. Ejercicios Pr√°cticos</h2>

  <p class="text-gray-700 mb-6">
    A continuaci√≥n, dos ejercicios que aplican los conceptos vistos: estructuras de control, funciones, colecciones, nulabilidad y programaci√≥n orientada a objetos.
  </p>

  <!-- Ejercicio 1: Sin clases -->
  <div class="border-l-4 border-blue-500 pl-4 mb-8">
    <h3 class="text-xl font-semibold text-gray-800 mb-2">Ejercicio 1: Estad√≠sticas de calificaciones</h3>
    <p class="text-gray-700 mb-3">
      Escribe una funci√≥n que reciba una lista de calificaciones (enteros entre 0 y 100) y devuelva un mapa con:
      <code>"promedio"</code>, <code>"aprobados"</code> (‚â•60) y <code>"maxima"</code>.
      Si la lista est√° vac√≠a, devuelve valores por defecto seguros.
    </p>
    <h3 class="text-xl font-semibold text-gray-800 mb-2">Soluci√≥n:</h3>
    <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>Map&lt;String, dynamic&gt; analizarCalificaciones(List&lt;int&gt; calificaciones) {
  if (calificaciones.isEmpty) {
    return {"promedio": 0, "aprobados": 0, "maxima": null};
  }

  int aprobados = calificaciones.where((n) => n >= 60).length;
  double promedio = calificaciones.reduce((a, b) => a + b) / calificaciones.length;
  int maxima = calificaciones.reduce((a, b) => a > b ? a : b);

  return {
    "promedio": promedio,
    "aprobados": aprobados,
    "maxima": maxima
  };
}

void main() {
  List&lt;int&gt; notas = [85, 72, 58, 90, 45];
  var resultado = analizarCalificaciones(notas);
  print(resultado);
  // {promedio: 70.0, aprobados: 3, maxima: 90}
}</pre>
    </div>

    <p class="text-sm text-gray-600 mt-2">
      <strong>Conceptos aplicados:</strong> listas, funciones, operadores de colecci√≥n (<code>where</code>, <code>reduce</code>), nulabilidad, mapas.
    </p>
   

  <p class="text-gray-700 mb-4">
    Esta l√≠nea define una funci√≥n en Dart. Vamos a desglosar cada parte para entender su significado y prop√≥sito.
  </p>

  <div class="space-y-5">
    <div>
      <p class="text-gray-700 mt-2">
        La funci√≥n <code>analizarCalificaciones</code> indica que devuelve un <strong>mapa</strong> (diccionario) donde:
      </p>
      <ul class="list-disc pl-5 text-gray-700 mt-2 space-y-1">
        <li>Las <strong>claves</strong> son siempre de tipo <code>String</code> (ej. <code>"promedio"</code>, <code>"aprobados"</code>).</li>
        <li>Los <strong>valores</strong> pueden ser de <strong>cualquier tipo</strong> (<code>int</code>, <code>double</code>, <code>null</code>, etc.), gracias a la palabra clave <code>dynamic</code>.</li>
      </ul>
      <p class="text-gray-700 mt-2">
        Se usa <code>dynamic</code> aqu√≠ porque el mapa mezcla tipos distintos:
        <code>promedio</code> es un <code>double</code>, <code>aprobados</code> es un <code>int</code>,
        y <code>maxima</code> puede ser <code>int</code> o <code>null</code>.
      </p>
    </div>

    <div>
      <p class="text-gray-700 mt-2">
        Es el identificador que se usa para llamar a la funci√≥n en el c√≥digo:
      </p>
      <div class="bg-gray-800 text-green-400 p-3 rounded mt-2 font-mono text-sm overflow-x-auto">
        <pre>var resultado = analizarCalificaciones([80, 90, 70]);</pre>
      </div>
    </div>
  </div>

  <div class="bg-blue-50 p-3 rounded mt-6">
    <p class="text-blue-800 text-sm">
      <strong>üí° En resumen:</strong>  
      <em>‚ÄúEsta funci√≥n toma una lista de calificaciones (enteros) y devuelve un mapa con estad√≠sticas cuyos valores pueden ser de distintos tipos.‚Äù</em>
    </p>
  </div>

  <h3 class="text-lg font-semibold text-gray-800 mt-6 mb-2">Alternativa m√°s segura (opcional)</h3>
  <p class="text-gray-700 mb-2">
    En lugar de usar <code>Map&lt;String, dynamic&gt;</code>, puedes crear una clase para mejorar la seguridad de tipos:
  </p>
  <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>class ReporteCalificaciones {
  final double promedio;
  final int aprobados;
  final int? maxima;
  ReporteCalificaciones(this.promedio, this.aprobados, this.maxima);
}</pre>
  </div>
  <p class="text-gray-700 text-sm italic">
    Esto evita el uso de <code>dynamic</code> y permite al compilador detectar errores antes de ejecutar el programa.
  </p>
  </div>

  <!-- Ejercicio 2: Con clases -->
  <div class="border-l-4 border-purple-500 pl-4">
    <h3 class="text-xl font-semibold text-gray-800 mb-2">Ejercicio 2: Gesti√≥n de una biblioteca</h3>
    <p class="text-gray-700 mb-3">
      Crea las clases <code>Libro</code> y <code>Biblioteca</code>. La biblioteca debe permitir:
      a√±adir libros, buscar por t√≠tulo (ignorando may√∫sculas), y obtener una lista de libros disponibles.
      Usa encapsulamiento y m√©todos seguros.
    </p>
 <h3 class="text-xl font-semibold text-gray-800 mb-2">Soluci√≥n:</h3>
    <div class="bg-gray-800 text-green-400 p-4 rounded my-3 font-mono text-sm overflow-x-auto">
<pre>class Libro {
  final String titulo;
  final String autor;
  bool _disponible = true;

  Libro(this.titulo, this.autor);

  bool get disponible => _disponible;
  void prestar() => _disponible = false;
  void devolver() => _disponible = true;

  @override
  String toString() => "Libro: \$titulo por \$autor";
}

class Biblioteca {
  final List&lt;Libro&gt; _libros = [];

  void agregarLibro(Libro libro) {
    _libros.add(libro);
  }

  Libro? buscarPorTitulo(String titulo) {
    return _libros.firstWhere(
      (libro) => libro.titulo.toLowerCase() == titulo.toLowerCase(),
      orElse: () => null,
    );
  }

  List&lt;Libro&gt; get disponibles => _libros.where((l) => l.disponible).toList();
}

void main() {
  var biblio = Biblioteca();
  biblio.agregarLibro(Libro("Cien a√±os de soledad", "Garc√≠a M√°rquez"));
  biblio.agregarLibro(Libro("1984", "Orwell"));

  var libro = biblio.buscarPorTitulo("1984");
  if (libro != null) libro.prestar();

  print("Disponibles: \${biblio.disponibles.length}");
  // Disponibles: 1
}</pre>
    </div>

    <p class="text-sm text-gray-600 mt-2">
      <strong>Conceptos aplicados:</strong> clases, encapsulamiento (propiedad privada con <code>_</code>), getters, m√©todos, colecciones, nulabilidad, <code>firstWhere</code> con <code>orElse</code>.
    </p>
  </div>
</section>

 

    <!-- Footer -->
    <footer class="text-center text-gray-500 text-sm mt-12">
      <p>Apuntes de Dart ‚Äì Fundamentos | Generado con Tailwind CSS</p>
    </footer>
  </div>
</body>
</html>

